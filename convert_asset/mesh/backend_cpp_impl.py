# -*- coding: utf-8 -*-
"""Implementation helpers for C++ QEM backend.

This module keeps low-level details (USD mesh extraction, OBJ I/O,
UV triplet handling), so that `backend_cpp.py` can expose a thin,
stable interface.
"""
from __future__ import annotations

import os
import subprocess
import tempfile
from typing import Any, Optional

try:
    from pxr import UsdGeom  # type: ignore
except Exception:  # pragma: no cover
    UsdGeom = None  # type: ignore[assignment]


def extract_tri_mesh_from_prim(prim: Any) -> tuple[
    list[tuple[float, float, float]],
    list[tuple[int, int, int]],
]:
    if UsdGeom is None:
        raise RuntimeError("pxr.UsdGeom not available; run inside Isaac/pxr environment")
    mesh = UsdGeom.Mesh(prim)
    counts = mesh.GetFaceVertexCountsAttr().Get()
    indices = mesh.GetFaceVertexIndicesAttr().Get()
    pts = mesh.GetPointsAttr().Get() or []
    if not counts or not indices or not pts:
        return [], []
    if not all(int(c) == 3 for c in counts):
        raise RuntimeError("Non-triangle face encountered; C++ backend expects triangles")
    faces: list[tuple[int, int, int]] = []
    it = iter(indices)
    for _ in counts:
        a = int(next(it)); b = int(next(it)); c = int(next(it))
        faces.append((a, b, c))
    points = [(float(p[0]), float(p[1]), float(p[2])) for p in pts]
    return points, faces


def extract_facevarying_uv_triplets(prim: Any) -> Optional[list[tuple[float, float, float, float, float, float]]]:
    if UsdGeom is None:
        raise RuntimeError("pxr.UsdGeom not available; run inside Isaac/pxr environment")
    mesh = UsdGeom.Mesh(prim)
    counts = mesh.GetFaceVertexCountsAttr().Get()
    if not counts:
        return None
    try:
        st_pv = UsdGeom.PrimvarsAPI(mesh).GetPrimvar("st")
        if not st_pv or not st_pv.HasValue():
            return None
        interp = st_pv.GetInterpolation()
        if interp != UsdGeom.Tokens.faceVarying:
            return None
        uv_vals = st_pv.Get() or []
        total_corners = sum(int(c) for c in counts)
        if not uv_vals or len(uv_vals) != total_corners:
            return None
        out: list[tuple[float, float, float, float, float, float]] = []
        it_idx = 0
        for c in counts:
            c = int(c)
            if c != 3:
                it_idx += c
                continue
            uv0 = uv_vals[it_idx]
            uv1 = uv_vals[it_idx + 1]
            uv2 = uv_vals[it_idx + 2]
            u0, v0 = float(uv0[0]), float(uv0[1])
            u1, v1 = float(uv1[0]), float(uv1[1])
            u2, v2 = float(uv2[0]), float(uv2[1])
            out.append((u0, v0, u1, v1, u2, v2))
            it_idx += 3
        return out
    except Exception:
        return None


def write_obj_tri(path: str, points: list[tuple[float, float, float]], faces: list[tuple[int, int, int]]):
    with open(path, "w", encoding="utf-8") as f:
        f.write("# obj generated by backend_cpp_impl\n")
        for x, y, z in points:
            f.write(f"v {x} {y} {z}\n")
        for a, b, c in faces:
            f.write(f"f {a+1} {b+1} {c+1}\n")


def read_obj_tri(path: str) -> tuple[list[tuple[float, float, float]], list[tuple[int, int, int]]]:
    pts: list[tuple[float, float, float]] = []
    faces: list[tuple[int, int, int]] = []
    with open(path, "r", encoding="utf-8") as f:
        for line in f:
            if not line or line.startswith("#"):
                continue
            if line.startswith("v "):
                _, xs, ys, zs = line.strip().split()
                pts.append((float(xs), float(ys), float(zs)))
            elif line.startswith("f "):
                _, a, b, c = line.strip().split()
                def _pi(s: str) -> int:
                    s = s.split("/")[0]
                    return int(s) - 1
                faces.append((_pi(a), _pi(b), _pi(c)))
    return pts, faces


def run_meshqem_executable(
    exe_path: str,
    inp_obj: str,
    out_obj: str,
    *,
    ratio: Optional[float] = None,
    target_faces: Optional[int] = None,
    max_collapses: Optional[int] = None,
    time_limit: Optional[float] = None,
    progress_interval: Optional[int] = 20000,
    show_output: bool = False,
) -> None:
    exe_path = os.path.abspath(exe_path)
    if not os.path.exists(exe_path):
        raise RuntimeError(f"C++ executable not found: {exe_path}")
    if not os.access(exe_path, os.X_OK):
        raise RuntimeError(f"C++ executable is not executable: {exe_path}")

    cmd: list[str] = [exe_path, "--in", inp_obj, "--out", out_obj]
    if target_faces is not None:
        cmd += ["--target-faces", str(int(target_faces))]
    elif ratio is not None:
        cmd += ["--ratio", str(float(ratio))]
    if max_collapses is not None:
        cmd += ["--max-collapses", str(int(max_collapses))]
    if time_limit is not None:
        cmd += ["--time-limit", str(float(time_limit))]
    if progress_interval is not None:
        cmd += ["--progress-interval", str(int(progress_interval))]

    if show_output:
        proc = subprocess.run(cmd)
    else:
        proc = subprocess.run(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)
    if proc.returncode != 0:
        raise RuntimeError(f"meshqem failed rc={proc.returncode}: {proc.stderr}\ncmd={' '.join(cmd)}")
