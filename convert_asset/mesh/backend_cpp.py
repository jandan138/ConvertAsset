# -*- coding: utf-8 -*-
"""
Backend adapter to use native C++ meshqem executable for QEM decimation.

Workflow per Mesh prim:
- Export mesh points/topology to a temporary OBJ file (triangles only)
- Call meshqem with ratio/target settings
- Read back simplified OBJ and set USD Mesh attributes
"""
from __future__ import annotations

import os
import subprocess
import tempfile
from typing import Any, Optional

try:
    from pxr import Usd, UsdGeom  # type: ignore
except Exception:
    Usd = None  # type: ignore[assignment]
    UsdGeom = None  # type: ignore[assignment]


def _write_obj_tri(path: str, points: list[tuple[float, float, float]], faces: list[tuple[int, int, int]]):
    with open(path, "w", encoding="utf-8") as f:
        f.write("# obj generated by backend_cpp\n")
        for x, y, z in points:
            f.write(f"v {x} {y} {z}\n")
        for a, b, c in faces:
            f.write(f"f {a+1} {b+1} {c+1}\n")


def _read_obj_tri(path: str) -> tuple[list[tuple[float, float, float]], list[tuple[int, int, int]]]:
    pts: list[tuple[float, float, float]] = []
    faces: list[tuple[int, int, int]] = []
    with open(path, "r", encoding="utf-8") as f:
        for line in f:
            if not line or line.startswith("#"):
                continue
            if line.startswith("v "):
                _, xs, ys, zs = line.strip().split()
                pts.append((float(xs), float(ys), float(zs)))
            elif line.startswith("f "):
                _, a, b, c = line.strip().split()
                def _pi(s: str) -> int:
                    s = s.split("/")[0]
                    return int(s) - 1
                faces.append((_pi(a), _pi(b), _pi(c)))
    return pts, faces


def simplify_mesh_with_cpp(
    prim: Any,
    exe_path: str,
    ratio: float | None = None,
    target_faces: int | None = None,
    max_collapses: int | None = None,
    time_limit: float | None = None,
    progress_interval: int = 20000,
        apply: bool = True,
        show_output: bool = False,
) -> tuple[int, int, int, int]:
    if Usd is None or UsdGeom is None:
        raise RuntimeError("pxr.Usd not available; run inside Isaac/pxr environment")
        exe_path = os.path.abspath(exe_path)
        if not os.path.exists(exe_path):
            raise RuntimeError(f"C++ executable not found: {exe_path}")
        if not os.access(exe_path, os.X_OK):
            # Try to chmod +x? No, just report for now
            raise RuntimeError(f"C++ executable is not executable: {exe_path}")

    mesh = UsdGeom.Mesh(prim)
    counts = mesh.GetFaceVertexCountsAttr().Get()
    indices = mesh.GetFaceVertexIndicesAttr().Get()
    pts = mesh.GetPointsAttr().Get() or []
    if not counts or not indices or not pts:
        return (0, 0, 0, 0)
    if not all(int(c) == 3 for c in counts):
        raise RuntimeError("Non-triangle face encountered; C++ backend expects triangles")
    # Build faces
    faces: list[tuple[int, int, int]] = []
    it = iter(indices)
    for _ in counts:
        a = int(next(it)); b = int(next(it)); c = int(next(it))
        faces.append((a, b, c))
    points = [(float(p[0]), float(p[1]), float(p[2])) for p in pts]

    with tempfile.TemporaryDirectory() as td:
        inp = os.path.join(td, "in.obj")
        out = os.path.join(td, "out.obj")
        _write_obj_tri(inp, points, faces)
        cmd = [exe_path, "--in", inp, "--out", out]
        if target_faces is not None:
            cmd += ["--target-faces", str(int(target_faces))]
        elif ratio is not None:
            cmd += ["--ratio", str(float(ratio))]
        if max_collapses is not None:
            cmd += ["--max-collapses", str(int(max_collapses))]
        if time_limit is not None:
            cmd += ["--time-limit", str(float(time_limit))]
        if progress_interval is not None:
            cmd += ["--progress-interval", str(int(progress_interval))]

            if show_output:
                proc = subprocess.run(cmd)
            else:
                proc = subprocess.run(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)
        if proc.returncode != 0:
            raise RuntimeError(f"meshqem failed rc={proc.returncode}: {proc.stderr}\ncmd={' '.join(cmd)}")

        new_pts, new_faces = _read_obj_tri(out)
        if apply:
            # write back
            mesh.GetPointsAttr().Set(new_pts)
            counts2 = [3] * len(new_faces)
            idx2: list[int] = []
            for a, b, c in new_faces:
                idx2.extend([int(a), int(b), int(c)])
            mesh.GetFaceVertexCountsAttr().Set(counts2)
            mesh.GetFaceVertexIndicesAttr().Set(idx2)

        return (len(faces), len(new_faces), len(points), len(new_pts))
